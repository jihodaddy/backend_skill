# CQRS 와 이벤트 소싱

- CQRS(Conmmand and Query Responsibility Segregation, 명령과 조회의 책임 분리)

  - CQRS에서 명령은 시스템의 상태를 변경하는 작업을 의미하며 조회는 시스템의 상태를 반환하는 작업을 의미
  - 즉, 시스템의 상태를 변경하는 작업과 시스템의 상태를 반환하는 작업의 책임을 분리하는 것

- QRS를 설명하는 정보들이 표현하는 구현체의 모습이 제각각이고 여기서 혼란이 시작될 가능성이 있습니다.
- CQRS를 설명할 때 명령 처리기 패턴(Command Processor Pattern)을 얘기하기도 하고
- 다른 경우는 다계층 아키텍처(Multitier Architecture)나 이벤트 소싱(Event Sourcing)을 다룹니다.
- 이것들 모두와 DDD(Domain-Driven Design)를 조합하기도 합니다.

- 더 복잡해지거나 (JPA 예)

  - 어떤 로딩(eager, lazy)을 사용할지는 기능에 따라 다름

- 주문을 취소하는 기능
  - Order, OrderLine 만 있으면 되므로 Order를 로딩할때 User를 eager로 로딩할 필요가 없음
- 주문의 목록을 조회하는 기능
  - 사용자 정보를 함께 보여줘야 하므로 User 를 Join 해서 eager로 로딩
    단일 모델을 유지하려고 노력하다 보면 다른 부분에서 복잡한 일이 생기게 됨

### 예시

- MemberCommandApi : 명령을 위한 구성요소
- MemberQueryApi: Query를 위한 구성요소
  ![cqrs](https://user-images.githubusercontent.com/94466572/173595334-aac63682-93ae-4ba4-b885-02f4e79a20b3.png)

- 기능에 따라서 사용하는 필드가 달라짐
  - 예를 들어 이름변경 기능에서는 Member 테이블에 해당하는 데이터만 읽어와서 Member 객체를 만들고
  - 주문목록 조회 기능에서는 세개의 테이블을 이용해서 Member 객체를 만들게 됨
- 이도 저도 아니게 됨

  - 코드 역할/책임 모호
  - 의미/가독성 등 나빠짐
  - 시스템이 복잡해질 수록 유지보수성이 떨어짐
    ![명령조회단일모델2](https://user-images.githubusercontent.com/94466572/173595359-2024c9e1-e9c1-41b3-aa91-0d66506d7167.png)

- 더 복잡해지거나 (JPA 예)

  - 어떤 로딩(eager, lazy)을 사용할지는 기능에 따라 다름

  - 주문을 취소하는 기능
    - Order, OrderLine 만 있으면 되므로 Order를 로딩할때 User를 eager로 로딩할 필요가 없음
  - 주문의 목록을 조회하는 기능 - 사용자 정보를 함께 보여줘야 하므로 User 를 Join 해서 eager로 로딩
    단일 모델을 유지하려고 노력하다 보면 다른 부분에서 복잡한 일이 생기게 됨
    ![명령과쿼리3](https://user-images.githubusercontent.com/94466572/173595372-98cf95b8-855c-4f74-8644-1e1e84ecc3b6.png)

### 기능마다 성능 요구가 다름

- 기능마다 트래픽 패턴, 성능 요구가 기능마다 다름
  - 사용자의 상품 목록 조회, 상품 상세 조회
    - 트래픽이 상대적으로 많은 시간대가 있고 빨리 보여줘야 함
    - 상품 목록 조회가 지연되면 고객이 이탈함
- 사용자의 댓글 등록
- 사용자의 주문
- 백오피스의 판매 수치
  - 조금 늦게 나와도 상관 없음
- 기능마다 서로 다른 성능 향상 방법 필요
  - 단일 모델로는 다양한 성능 향상 기법 적용이 어려울 수 있음

### 그래서 명령과 쿼리를 구분

명령과 쿼리를 위한 모델을 분리하면 앞에서 언급했던 문제들이 줄어들게 됨

- 모델의 모호함이 없어짐
  - 명령영역의 모델과 쿼리영역의 모델이 무엇을 표현하고 있는지가 명확해짐
  - 전반적인 코드 가독성과 유지보수성이 좋아질 가능성이 높아진다
  - 쿼리 쪽은 캐쉬를 적용하고 명령 쪽은 비동기를 적용하는 식으로 기능에 따라서 성능향상 기법을 다르게 적용하는 것도 용이해짐
    ![명령조회분리4](https://user-images.githubusercontent.com/94466572/173595378-e16585fe-2212-4a1b-abd9-dcf57d2d5ddd.png)

# 이벤트 소싱

- `이벤트 소싱이란?`
  - 데이터 저장 방식 중 하나로 **발생한 이벤트를 저장하는 기법.**
  - 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장하는 기법. 각 이벤트는 애그리커트의 상태 변화를 나타냄. (애그리거트는 상태가 - 바뀔 때마다 반드시 이벤트를 발생시킴.)
    - 에그리거트: DDD(domain-driven design)에 기반한 설계에서 하나의 도메인에서 필요한 객체들을 하나로 모아놓은 것.
      **하나의 트랜잭션에서는 하나의 애그리거트만 업데이트.**
  - 이벤트 저장소에 해당 이벤트를 순차적으로 저장해서 관리. 이벤트의 최종 결과값이 아닌 **전체 순서를 모두 저장하여 관리.**
- `이벤트 소싱 실사용 예시)` **버전 관리 시스템**
  - 변경 내역만 저장
  - 지금 상태를 볼때는 변경 내역을 재생
- `사용하는 이유?`
  - 전통적인 방식과의 비교 (기존 영속화 방식; ORM: Object Relational Mapping)
    - 애그리거트 이력이 없음
      - 애그리거트가 업데이트되면 이전 상태가 없어짐. 따라서 관리 용도로 보존하려면 추가 개발이 필요. 비즈니스 로직과 동기화되도록 개발해야 하므로 개발 난이도가 높음.
      - MSA에서는 **각 서비스마다 각자의 데이터를 가지게 됨** => **데이터의 정합성**을 보장하는 게 어려워짐.
      - 따라서 데이터를 가진 서비스가 바로 데이터를 조작하게 하면 안 됨.
      - 이를 해결하기 위해,
        - 서비스는 이벤트를 발생시키고, event store에 저장
        - **이벤트 컨슈머**가 해당 이벤트를 DB나 HDFS에 들어온 순서대로 적재하고 필요 데이터를 변경함.
  - 이벤트 소싱은 **클라우드에서 구동되는 메시지 중심의 분산 시스템에 적합.**

[참고 블로그](https://recordsoflife.tistory.com/661)

# CQRS 와 이벤트 소싱

- CQRS(Conmmand and Query Responsibility Segregation, 명령과 조회의 책임 분리)

  - CQRS에서 명령은 시스템의 상태를 변경하는 작업을 의미하며 조회는 시스템의 상태를 반환하는 작업을 의미
  - 즉, 시스템의 상태를 변경하는 작업과 시스템의 상태를 반환하는 작업의 책임을 분리하는 것

- QRS를 설명하는 정보들이 표현하는 구현체의 모습이 제각각이고 여기서 혼란이 시작될 가능성이 있습니다.
- CQRS를 설명할 때 명령 처리기 패턴(Command Processor Pattern)을 얘기하기도 하고
- 다른 경우는 다계층 아키텍처(Multitier Architecture)나 이벤트 소싱(Event Sourcing)을 다룹니다.
- 이것들 모두와 DDD(Domain-Driven Design)를 조합하기도 합니다.

- 더 복잡해지거나 (JPA 예)

  - 어떤 로딩(eager, lazy)을 사용할지는 기능에 따라 다름

- 주문을 취소하는 기능
  - Order, OrderLine 만 있으면 되므로 Order를 로딩할때 User를 eager로 로딩할 필요가 없음
- 주문의 목록을 조회하는 기능
  - 사용자 정보를 함께 보여줘야 하므로 User 를 Join 해서 eager로 로딩
    단일 모델을 유지하려고 노력하다 보면 다른 부분에서 복잡한 일이 생기게 됨

### 예시

- MemberCommandApi : 명령을 위한 구성요소
- MemberQueryApi: Query를 위한 구성요소
  ![cqrs](https://user-images.githubusercontent.com/94466572/173595334-aac63682-93ae-4ba4-b885-02f4e79a20b3.png)

- 기능에 따라서 사용하는 필드가 달라짐
  - 예를 들어 이름변경 기능에서는 Member 테이블에 해당하는 데이터만 읽어와서 Member 객체를 만들고
  - 주문목록 조회 기능에서는 세개의 테이블을 이용해서 Member 객체를 만들게 됨
- 이도 저도 아니게 됨

  - 코드 역할/책임 모호
  - 의미/가독성 등 나빠짐
  - 시스템이 복잡해질 수록 유지보수성이 떨어짐
    ![명령조회단일모델2](https://user-images.githubusercontent.com/94466572/173595359-2024c9e1-e9c1-41b3-aa91-0d66506d7167.png)

- 더 복잡해지거나 (JPA 예)

  - 어떤 로딩(eager, lazy)을 사용할지는 기능에 따라 다름

  - 주문을 취소하는 기능
    - Order, OrderLine 만 있으면 되므로 Order를 로딩할때 User를 eager로 로딩할 필요가 없음
  - 주문의 목록을 조회하는 기능 - 사용자 정보를 함께 보여줘야 하므로 User 를 Join 해서 eager로 로딩
    단일 모델을 유지하려고 노력하다 보면 다른 부분에서 복잡한 일이 생기게 됨
    ![명령과쿼리3](https://user-images.githubusercontent.com/94466572/173595372-98cf95b8-855c-4f74-8644-1e1e84ecc3b6.png)

### 기능마다 성능 요구가 다름

- 기능마다 트래픽 패턴, 성능 요구가 기능마다 다름
  - 사용자의 상품 목록 조회, 상품 상세 조회
    - 트래픽이 상대적으로 많은 시간대가 있고 빨리 보여줘야 함
    - 상품 목록 조회가 지연되면 고객이 이탈함
- 사용자의 댓글 등록
- 사용자의 주문
- 백오피스의 판매 수치
  - 조금 늦게 나와도 상관 없음
- 기능마다 서로 다른 성능 향상 방법 필요
  - 단일 모델로는 다양한 성능 향상 기법 적용이 어려울 수 있음

### 그래서 명령과 쿼리를 구분

명령과 쿼리를 위한 모델을 분리하면 앞에서 언급했던 문제들이 줄어들게 됨

- 모델의 모호함이 없어짐
  - 명령영역의 모델과 쿼리영역의 모델이 무엇을 표현하고 있는지가 명확해짐
  - 전반적인 코드 가독성과 유지보수성이 좋아질 가능성이 높아진다
  - 쿼리 쪽은 캐쉬를 적용하고 명령 쪽은 비동기를 적용하는 식으로 기능에 따라서 성능향상 기법을 다르게 적용하는 것도 용이해짐
    ![명령조회분리4](https://user-images.githubusercontent.com/94466572/173595378-e16585fe-2212-4a1b-abd9-dcf57d2d5ddd.png)
